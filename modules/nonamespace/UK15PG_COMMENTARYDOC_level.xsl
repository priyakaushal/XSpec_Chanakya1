<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/"
    xmlns:dita="http://dita.oasis-open.org/architecture/2005/"
    xmlns:comm="http://www.lexis-nexis.com/glp/comm"
    xmlns:seclaw="http://www.lexisnexis.com/xmlschemas/content/legal/secondary-law/1/" version="2.0"
    exclude-result-prefixes="dita">

    <dita:topic xmlns="http://dita.oasis-open.org/architecture/2005/"
        id="UK15PG_COMMENTARYDOC_level">
        <title>level <lnpid>id-UK15-30418</lnpid></title>

        <body>
            <p><sourcexml>level</sourcexml> becomes <targetxml>seclaw:level</targetxml> with the
                value of <sourcexml>level/@leveltype</sourcexml> becoming the value of
                    <targetxml>seclaw:level/@leveltype</targetxml>. If
                    <sourcexml>@leveltype</sourcexml> is not present in
                <sourcexml>level</sourcexml>, then <sourcexml>level/@leveltype</sourcexml> should be
                set to a value of "topic".</p>
            <p>If <sourcexml>level</sourcexml> is the child of another <sourcexml>level</sourcexml>,
                then it should be mapped to the <targetxml>seclaw:bodytext</targetxml> of the parent
                    <targetxml>seclaw:level</targetxml>.</p>
            <example>
                <title>Source XML</title>
                <codeblock> &lt;comm:body&gt; &lt;level leveltype="division"&gt; &lt;heading&gt;
                    &lt;title&gt;Terms of art or special terms&lt;/title&gt; &lt;/heading&gt;
                    &lt;bodytext&gt; &lt;p&gt; &lt;text&gt;This Practice Note deals with contractual
                    terms that are terms of art or that have a special application in particular
                    industries or sectors.&lt;/text&gt; &lt;/p&gt; &lt;/bodytext&gt; &lt;level
                    leveltype="section"&gt; &lt;heading&gt; &lt;title&gt;Good faith&lt;/title&gt;
                    &lt;/heading&gt; &lt;bodytext&gt; &lt;p&gt; &lt;text&gt;As there is no
                    statutorily implied term of good faith in English law contracts, there is not a
                    settled precedent or authority to define what good faith is. A common definition
                    is provided under common law in the judgment of Bingham LJ in &lt;emph
                    typestyle="it"&gt;Interfoto Picture Library v Stiletto Visual
                    Programmes&lt;/emph&gt;:&lt;/text&gt; &lt;/p&gt; ... &lt;/bodytext&gt;
                    &lt;/level&gt; ... &lt;/level&gt; &lt;/comm:body&gt; </codeblock>
                <title>Target XML</title>
                <codeblock> &lt;seclaw:body&gt; &lt;seclaw:level leveltype="division"&gt;
                    &lt;heading&gt; &lt;title&gt;Terms of art or special terms&lt;/title&gt;
                    &lt;/heading&gt; &lt;seclaw:bodytext&gt; &lt;p&gt; &lt;text&gt;This Practice
                    Note deals with contractual terms that are terms of art or that have a special
                    application in particular industries or sectors.&lt;/text&gt; &lt;/p&gt;
                    &lt;seclaw:level leveltype="section"&gt; &lt;heading&gt; &lt;title&gt;Good
                    faith&lt;/title&gt; &lt;/heading&gt; &lt;seclaw:bodytext&gt; &lt;p&gt;
                    &lt;text&gt;As there is no statutorily implied term of good faith in English law
                    contracts, there is not a settled precedent or authority to define what good
                    faith is. A common definition is provided under common law in the judgment of
                    Bingham LJ in &lt;emph typestyle="it"&gt;Interfoto Picture Library v Stiletto
                    Visual Programmes&lt;/emph&gt;:&lt;/text&gt; &lt;/p&gt; ...
                    &lt;/seclaw:bodytext&gt; &lt;/seclaw:level&gt; ... &lt;/seclaw:bodytext&gt;
                    &lt;/seclaw:level&gt; &lt;/seclaw:body&gt; </codeblock>
            </example>
        </body>
    </dita:topic>

    <!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
    <!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-UK\UK15-PracticalGuidance\UK15PG_COMMENTARYDOC_level.dita  -->
    <!--	<xsl:message>UK15PG_COMMENTARYDOC_level.xsl requires manual development!</xsl:message> -->


    <xsl:template match="level[parent::comm:body]">
        <seclaw:level>
            <xsl:attribute name="leveltype">
                <xsl:value-of select="@leveltype"/>
            </xsl:attribute>
            <xsl:apply-templates
                select="@* | node() except (level[preceding-sibling::*[1][name() = 'bodytext']])"/>
        </seclaw:level>
    </xsl:template>

    <!-- BRT 11/27/17 - modified template to add [not(preceding-sibling::bodytext[not(./child::references[1]) .... to avoid ambiguity error with that template -->
    <xsl:template match="level[1][parent::level][not(preceding-sibling::bodytext[not(./child::references[1]) or ./child::references[1]/preceding-sibling::node()])]">
        <seclaw:bodytext>
            <xsl:choose>
                <xsl:when test="child::heading/title/refpt">
                    <seclaw:level>
                        <xsl:attribute name="leveltype">
                            <xsl:value-of select="@leveltype"/>
                        </xsl:attribute>
                        <!--<xsl:apply-templates select="child::heading/title/refpt"/>-->
                        <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
                    </seclaw:level>
                </xsl:when>
                <xsl:when test="child::heading/title and not(child::heading/title/refpt)">
                    <seclaw:level>
                        <xsl:attribute name="leveltype">
                            <xsl:value-of select="@leveltype"/>
                        </xsl:attribute>
                        <!--<xsl:apply-templates select="child::heading/title"/>-->
                        <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
                    </seclaw:level>
                </xsl:when>
                <xsl:when test="child::bodytext/references/heading/title/refpt">
                    <seclaw:level>
                        <xsl:attribute name="leveltype">
                            <xsl:value-of select="@leveltype"/>
                        </xsl:attribute>
                        <!--<xsl:apply-templates select="child::bodytext/references/heading/title/refpt"/>-->
                        <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
                    </seclaw:level>
                </xsl:when>
            </xsl:choose>
            <xsl:for-each select="following-sibling::level[1]">
                <xsl:call-template name="following-level"/>
            </xsl:for-each>            
        </seclaw:bodytext>
    </xsl:template>
    
    <xsl:template name="following-level">
        <xsl:choose>
            <xsl:when test="child::heading/title/refpt">
                <seclaw:level>
                    <xsl:attribute name="leveltype">
                        <xsl:value-of select="@leveltype"/>
                    </xsl:attribute>
                    <xsl:apply-templates select="child::heading/title/refpt"/>
                    <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
                </seclaw:level>
                <xsl:apply-templates select="following-sibling::level[preceding-sibling::*[1][self::level]]" mode="level_wrapping"/>
            </xsl:when>
            <xsl:when test="child::heading/title and not(child::heading/title/refpt)">
                <seclaw:level>
                    <xsl:attribute name="leveltype">
                        <xsl:value-of select="@leveltype"/>
                    </xsl:attribute>
                    <!--<xsl:apply-templates select="child::heading/title"/>-->
                    <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
                </seclaw:level>
            </xsl:when>
            <xsl:when test="child::bodytext/references/heading/title/refpt and not(/COMMENTARYDOC/comm:body[1]/level[1]/level[6]/bodytext[1]/references[1])">
                <seclaw:level>
                    <xsl:attribute name="leveltype">
                        <xsl:value-of select="@leveltype"/>
                    </xsl:attribute>
                    <xsl:apply-templates select="child::bodytext/references/heading/title/refpt"/>
                    <xsl:apply-templates select="@* | node() except (level[preceding-sibling::bodytext])"/>
                </seclaw:level>
            </xsl:when>
        </xsl:choose>
    </xsl:template>
    <xsl:template match="level" mode="level_wrapping">
        <seclaw:level>
            <xsl:attribute name="leveltype">
                <xsl:value-of select="@leveltype"/>
            </xsl:attribute>
            <xsl:apply-templates select="@* | node()"/>
        </seclaw:level>
    </xsl:template>
    
    <xsl:template match="@subdoc">
        <xsl:attribute name="includeintoc">
            <xsl:value-of select="."/>
        </xsl:attribute>
    </xsl:template>

    <xsl:template match="@toc-caption">
        <xsl:attribute name="alternatetoccaption">
            <xsl:value-of select="."/>
        </xsl:attribute>

    </xsl:template>

    <xsl:template match="level/@leveltype"/>
    
    <xsl:template match="level[preceding-sibling::level[ancestor::level]]" priority="2"/>
    <xsl:template match="emph[parent::title][child::refpt]">
        <xsl:apply-templates select="node() except refpt"/>
    </xsl:template>
</xsl:stylesheet>
