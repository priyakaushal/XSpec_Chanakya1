<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:dita="http://dita.oasis-open.org/architecture/2005/"
	xmlns:ci="http://www.lexis-nexis.com/ci" xmlns:leg="http://www.lexis-nexis.com/glp/leg"
	xmlns:primlawinfo="http://www.lexisnexis.com/xmlschemas/content/legal/primarylaw-info/1/"
	xmlns:docinfo="http://www.lexis-nexis.com/glp/docinfo"
	xmlns:legisinfo="http://www.lexisnexis.com/xmlschemas/content/legal/legislation-info/1/"
	xmlns:classify="http://www.lexisnexis.com/xmlschemas/content/shared/classification/1/" xmlns:proc="http://www.lexisnexis.com/xmlschemas/content/shared/process-elements/1/"
	xmlns:lnci="http://www.lexisnexis.com/xmlschemas/content/shared/citations/1/" xmlns:doc="http://www.lexisnexis.com/xmlschemas/content/shared/document-level-metadata/1/"
	xmlns:ref="http://www.lexisnexis.com/xmlschemas/content/shared/reference/1/"
	xmlns:xs="http://www.w3.org/2001/XMLSchema"
	xmlns:lnf="urn:x-lexisnexis:conversion:global:functions:1"
    exclude-result-prefixes="#all"
	version="2.0"
	>
	<dita:topic xmlns="http://dita.oasis-open.org/architecture/2005/" id="leg.num">
		<title>leg:num <lnpid>id-CA08-14224</lnpid></title>
		<body>
			<section> When <sourcexml>leg:num</sourcexml> contains just text then it will get
				converted into <targetxml>ref:citations/ref:cite4thisresource</targetxml> with
				attribute <targetxml>@citetype="reporter"</targetxml> and create child
					<targetxml>lnci:cite/lnci:content</targetxml> to capture the text. </section>

			<example>
				<title>Mapping of <sourcexml>leg:num</sourcexml> with text only</title>
				<codeblock> &lt;leg:num&gt;LRC 1985 appII no44 annB expl art50&lt;/leg:num&gt; </codeblock>
				<b>becomes</b>
				<codeblock> &lt;ref:citations&gt; &lt;ref:cite4thisresource citetype="reporter"&gt;
					&lt;lnci:cite&gt; &lt;lnci:content&gt;LRC 1985 appII no44 annB expl
					art50&lt;/lnci:content&gt; &lt;/lnci:cite&gt; &lt;/ref:cite4thisresource&gt;
					&lt;/ref:citations&gt; </codeblock>
			</example>
			<section>
				<title>changes</title>
				<p>2014-12-16 : <ph id="change_20141216_SS"> Updated instruction and example for
						adding attribute <targetxml>@citetype</targetxml> with "<b>reporter</b>"
						value inside the <targetxml>ref:cite4thisresource</targetxml> in target
						conversion</ph>.</p>
				<p>2014-06-20 : <ph id="change_20140620_CSN"> Removed instruction and example for
						when No <b>leg:num</b> exists, per LBU 6/19/14. Docs with no leg:num have no
						officialnum either. Also, removed solsak note and example since it is
						covered elsewhere in this CI.</ph></p>
				<p>2014-05-29 : <ph id="change_20140529_SSX"> Added instruction and example, when No
							<b>leg:num</b> exit with text in it Webteam # 260692</ph></p>
			</section>
		</body>
	</dita:topic>

	<!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
	<!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-CAN\CA08-Constitutions\leg.num.dita  -->
	<!-- RS 2017-01-12 Updated the ref:parallelcite citetype="parallel template" and Citation value as per CI -->
	

	
	<xsl:variable name="dpsiRestricted">
		<!-- no ref:cite4thisresource or alternate language versions should be created for these restricted dpsis.
            they get ref:citations/ref:parallelcite[@citetype="reporter"] -->
		<xsl:if
			test="
			/LEGDOC/docinfo/docinfo:custom-metafields/docinfo:custom-metafield[@name = 'dpsi'] = ('0U95',
			'0U96',
			'0U9A',
			'0U9B',
			'0U9S',
			'0U9T',
			'0U9V',
			'0U9W',
			'0U9X',
			'0U9Y',
			'0UA4',
			'0UA5',
			'0UA6',
			'0UA7',
			'0UAN',
			'0UAO',
			'0UAP',
			'0UAQ',
			'0UCM',
			'0UCN',
			'0UCO',
			'0UCP',
			'0UCV',
			'0UCW',
			'0UCX',
			'0UCY',
			'0UD9',
			'0UDA',
			'0UDB',
			'0UDC',
			'0UDF',
			'0UDG',
			'0UDL',
			'0UDM',
			'0UDN',
			'0UDO',
			'0UDT',
			'0UDU',
			'0UDV',
			'0UEE',
			'0UEF',
			'0UEG',
			'0UEJ',
			'0UFB',
			'0UFC',
			'0UFD',
			'0UFE',
			'0UFT',
			'0UFU',
			'0UHJ',
			'0UHK',
			'0UHL',
			'0UHM',
			'0UI1',
			'0UI2',
			'0UI3',
			'0UI4',
			'0UJ2',
			'0UJ3',
			'0UJ8',
			'0UJ9',
			'0UJA',
			'0UJB',
			'0UN0',
			'0UN5',
			'0UN6',
			'0UNO',
			'0UNP',
			'0UNZ',
			'0UOD',
			'0UOE',
			'0UOJ',
			'0UOK',
			'0UOS',
			'0UOT',
			'0UOV',
			'0UPV',
			'0UPW',
			'0UPX',
			'0UPY',
			'0US1',
			'0US6',
			'0US7',
			'0USC',
			'0USD',
			'0USP',
			'0UTB',
			'0UTC',
			'0UVY',
			'0UVZ')">
			<xsl:value-of select="'true'"/>
		</xsl:if>
	</xsl:variable>
	
	
	
	<xsl:variable name="sourceLanguage" select="/LEGDOC/docinfo/docinfo:doc-lang/@lang"/>
	<xsl:variable name="citationTranslationTable">
		<!-- the identification of the source language and a term will trigger the translation process.
    subterms are translations that only kick in in the context of that term itself. Order
    of sub/terms matters because we don't want to translate substring of larger strings that translate differently first.
    These terms are stream-specific, while I don't think the list of DPSIs really is.
        -->
		<terms>
			<term en="R.S.C." fr="L.R.C."/>
			<term en="George III" fr="George III"/>
			<term en="George IV" fr="George IV"/>
			<term en="Victoria" fr="Victoria"/>
			<term en="Edward VII" fr="Edouard VII"/>
			<term en="George V" fr="George V"/>
			<term en="George VI" fr="George VI"/>			
			<term en="Elizabeth II" fr="Elizabeth II"/>
			<subterm en="Repealed" fr="Abrogée"/>			
			<subterm en="Repeal Schedules" fr="Annexe abrogratives"/>
			<subterm en="Repeal Sch" fr="ann abrogative"/>
			<subterm en="Table of Contents" fr="Table des matières"/> 
			<subterm en="Appendix" fr="appendice"/>
			<subterm en="Preamble" fr="Préambule"/>
			<subterm en="Schedule" fr="annexe"/>
			<subterm en="Long Title" fr="Titre intégral"/>
			<!--<subterm en="Short Title" fr="Titre abrégé"/> -->
			<subterm en="(U.K.)" fr="(R.-U.)"/>
			<subterm en="TD" fr="DT"/>
			<subterm en="RP" fr="DC"/> 
			<subterm en="Form" fr="formule"/>
			<subterm en="Part" fr="Partie"/>
			<subterm en="s." fr="art."/>
			<subterm en="No." fr="no"/>
			<subterm en="c." fr="ch."/>
			<subterm en="(2nd Supp.)" fr="(2e suppl.)"/>
			<subterm en="(3rd Supp.)" fr="(3e suppl.)"/>
			<subterm en="(4th Supp.)" fr="(4e suppl.)"/>
			<subterm en="(5th Supp.)" fr="(5e suppl.)"/>
			<!-- think this will only kick in correctly if I put it after Appendix -->
			<subterm en="App." fr="appendice"/>
			<subterm en="Enactment Clause" fr="Formule d'édiction"/>
			<!-- do Enactment Clause last because it does weird things in interaction with Form-->
		</terms>
	</xsl:variable>
	
	<!-- begin questionable variables without which the stylesheet will not run but aren't used anymore for CA08 -->
	
	<xsl:variable name="exKey"
		select="matches(//ci:span[ancestor::leg:num], '31 George III') or matches(//ci:span[ancestor::leg:num], 'R.S.C.') or matches(//ci:span[ancestor::leg:num], 'L.R.C.') or matches(//ci:span[ancestor::leg:num], '23 Elizabeth II') or matches(//ci:span[ancestor::leg:num], '14 George III') or matches(//ci:span[ancestor::leg:num], '14 George VI') or matches(//ci:span[ancestor::leg:num], '23-24 Elizabeth') or matches(//ci:span[ancestor::leg:num], '13 George VI')"/>
	
	<xsl:variable name="Citation_Num">
		<codes>
			<code key="R.S.C." value="L.R.C."/>
			<code key="L.R.C." value="R.S.C."/>
				<xsl:choose>
				<xsl:when test="$exKey">
					<code key="App." value="appendice"/>
					<code key="s." value="art."/>
					<code key="No." value="no"/>
					<code key="c." value="ch."/>
					<code key="art." value="s."/>
					<code key="no" value="No."/>
					<code key="ch." value="c."/>
					<code key="appendice" value="Appendix"/>
					<code key="Appendix" value="appendice"/>
					<code key="Long" value="intégral"/>
					<code key="Title" value="Titre"/>
					<code key="Preamble" value="Préambule"/>
					<code key="Enactment Clause" value="Formule d'édiction"/>
					<code key="Schedule" value="annexe"/>
					<code key="2nd" value="2e"/>
					<code key="4th" value="4e"/>
					<code key="3rd" value="3e"/>
					<code key="5th" value="5e"/>
					<code key="Supp." value="suppl."/>
					<code key="DT" value="TD"/>
					<code key="DC" value="RP"/>
					<code key="Repeal" value="abrogative"/>
					<code key="Sch" value="ann"/>
					<code key="Repeal" value="abrogratives"/>
					<code key="Schedules" value="Annexe"/>
					<code key="Repealed" value="Abrogée"/>
					<code key="Form" value="formule"/>
					<code key="Part" value="Partie"/>
					<code key="Table" value="Table"/>
					<code key="of" value="des"/>
					<code key="Contents" value="matières"/>
					<code key="Titre" value="Long"/>   
					<code key="intégral" value="Title"/>
					<code key="Préambule" value="Preamble"/>
					<code key="Formule" value="Clause"/>
					<code key="d'édiction" value="Enactment"/>
					<code key="annexe" value="Schedule"/>
					<code key="2e" value="2nd"/>
					<code key="4e" value="4th"/>
					<code key="3e" value="3rd"/>
					<code key="5e" value="5th"/>
					<code key="suppl." value="Supp."/>
					<code key="TD" value="DT"/>
					<code key="RP" value="DC"/>
					<code key="ann" value="Sch"/>
					<code key="abrogative" value="Repeal"/>
					<code key="abrogratives" value="Repeal"/>
					<code key="Annexe" value="Schedules"/>
					<code key="Abrogée" value="Repealed"/>
					<code key="formule" value="Form"/>
					<code key="Partie" value="Part"/>
					<code key="Table" value="Table"/>
					<code key="des" value="of"/>
					<code key="matières" value="Contents"/>
					<code key="Edouard" value="Edward"/>
					<code key="Edward" value="Edouard"/>
					<code key="(U.K.)" value="R.-U."/>
					<code key="(R.-U.)" value="U.K."/>
					<code key="(Canada)" value="Canada"/>
					<code key="Canada" value="Canada"/>
					</xsl:when>
				<xsl:otherwise/>
			</xsl:choose>
			
			<code key="annexe" value="Schedule"/>
			<code key="Schedule" value="annexe"/>
		
		</codes>
	</xsl:variable>
	
	<xsl:variable name="CitFormat">
		<codes>
			<code key="R.S.C. 1985, App. II, No. 3" value="L.R.C. 1985, appendice II, no 22"/>
			<code key="R.S.C. 1985, Appendix II, No. 4, s. L" value="L.R.C. 1985, appendice II, no 4, art. L"/>
			<code key="31 George III, c. 31 (U.K.)" value="14 George III, ch. 83 (R.-U.)"/>
			<code key="23-24 Elizabeth II, c. 28 (Canada)" value="23 Elizabeth II, ch. 13 (Canada)"/>
			<code key="L.R.C. 1985, appendice II, no 22" value="R.S.C. 1985, Appendix II, No. 3"/>
			<code key="13 George VI, c. 81 (U.K.)" value="14 George VI, ch. 6 (R.-U.)"/>
			<code key="14 George III, ch. 83 (R.-U.)" value="31 George III, c. 31 (U.K.)"/>
			<code key="23 Elizabeth II, ch. 13 (Canada)" value="23-24 Elizabeth II, c. 28 (Canada)"/>
			<code key="14 George VI, ch. 6 (R.-U.)" value="13 George VI, c. 81 (U.K.)"/>
		</codes>
		
	</xsl:variable>	
	
	<!--end questionable variables -->
	
	<xsl:template match="leg:num" priority="2">
		
		<xsl:choose>
			<xsl:when test="contains(., 'solsak')">
				
				<classify:classification classscheme="legislation.indicator">
					<classify:classitem>
						<classify:classitem-identifier>
							<classify:classname>solsak</classify:classname>
						</classify:classitem-identifier>
					</classify:classitem>
				</classify:classification>
				
			</xsl:when>
			<xsl:otherwise>
				<ref:citations>
					<xsl:choose>
						<xsl:when test="$dpsiRestricted = 'true'">
							<!-- restricted dpsi 'WK' sources ONLY get this parallelcite and nothing else. Customers don't want them
                            searched on in the same way as our proprietary collection -->
							<ref:parallelcite citetype="reporter">
								<xsl:choose>
									<xsl:when test="ci:cite">
										<xsl:apply-templates
									select="node() except text()[preceding-sibling::node()[1][self::ci:cite]]"/>
								<!-- suppresses last text node sucked into lnci:content here since we deal with it in the 
								ci:content template -->
									</xsl:when>
									<xsl:otherwise>
										<lnci:cite>
											<lnci:content>
												<xsl:apply-templates/>
											</lnci:content>
										</lnci:cite>											
									</xsl:otherwise>
								</xsl:choose>								
							</ref:parallelcite>
						</xsl:when>
						<xsl:otherwise>
							<!--normal complement of citations for non 'WK' sources -->
							<ref:cite4thisresource>
								<xsl:attribute name="citetype">
									<xsl:text>reporter</xsl:text>
								</xsl:attribute>
								<xsl:choose>
									<xsl:when test="ci:cite">
										<xsl:apply-templates
											select="node() except text()[preceding-sibling::node()[1][self::ci:cite]]"/>
										<!-- suppresses last text node sucked into lnci:content here since we deal with it in the 
								ci:content template -->
									</xsl:when>
									<xsl:otherwise>
										<lnci:cite>
											<lnci:content>
												<xsl:apply-templates/>
											</lnci:content>
										</lnci:cite>
									</xsl:otherwise>
								</xsl:choose>
								
							</ref:cite4thisresource>
							<!-- perform translation if the dpsi isn't on the restricted list, 
						    if the source language is properly identified,
							and if the terms in the source language are present in the citation. -->
							<xsl:variable name="citationContent">
								<citationContent>
									<xsl:copy-of select="node()"/>
								</citationContent>
							</xsl:variable>
							<xsl:variable name="citationTextPossibilities">
								<xsl:for-each select="string($citationContent)">
									<xsl:value-of select="."/>
								</xsl:for-each>
							</xsl:variable>
							<xsl:choose>
								<xsl:when
									test="
									$sourceLanguage = 'en' and (some $i in $citationTranslationTable/terms/term/@en
									satisfies (contains($citationTextPossibilities, $i)))">
									
									<!-- alt language version detected with terms, create parallelcite translate English to French -->
									<ref:parallelcite citetype="parallel">
										<lnci:cite>
											<lnci:content>
												<xsl:for-each
													select="$citationContent/citationContent/text() | $citationContent//ci:content/text() | $citationContent//ci:content//ci:span/text()">
																					
													
														<xsl:call-template name="translate">
															<xsl:with-param name="string" select="."/>
															<xsl:with-param name="old"
																select="$citationTranslationTable/terms/*/@en/string()"/>
															<xsl:with-param name="new"
																select="$citationTranslationTable/terms/*/@fr/string()"/>															
														</xsl:call-template>
													
												</xsl:for-each>
											</lnci:content>
										</lnci:cite>
									</ref:parallelcite>
								</xsl:when>
								<xsl:when
									test="
									$sourceLanguage = 'fr' and (some $i in $citationTranslationTable/terms/term/@fr
									satisfies (contains($citationTextPossibilities, $i)))">
									<!-- alt language version detected with terms, create parallelcite translate French to English -->
									<ref:parallelcite citetype="parallel">
										<lnci:cite>
											<lnci:content>
												<xsl:for-each
													select="$citationContent/citationContent/text() | $citationContent//ci:content/text() | $citationContent//ci:content//ci:span/text()">
													<xsl:call-template name="translate">
														<xsl:with-param name="string" select="."/>
														<xsl:with-param name="old"
															select="$citationTranslationTable/terms/*/@fr/string()"/>
														<xsl:with-param name="new"
															select="$citationTranslationTable/terms/*/@en/string()"
														/>
													</xsl:call-template>
												</xsl:for-each>
											</lnci:content>
										</lnci:cite>
									</ref:parallelcite>
								</xsl:when>
							</xsl:choose>							
						</xsl:otherwise>
					</xsl:choose>
					<xsl:apply-templates select="following-sibling::leg:officialnum" mode="parallelcite"/>
				</ref:citations>
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template>
	
	
	<xsl:template match="leg:num[not(starts-with(.,'solsak'))]" mode="doc_related_content-alt-lang">
	
		<xsl:if test="not($dpsiRestricted = 'true')">
		<xsl:variable name="citationContent">
		<citationContent>
			<xsl:copy-of select="node()"/>
		</citationContent>			
		</xsl:variable>
			<xsl:variable name="citationTextPossibilities">
				<xsl:value-of select="string($citationContent)"/>
			</xsl:variable>
			<xsl:choose>
				<xsl:when
					test="
					$sourceLanguage = 'en' and (some $i in $citationTranslationTable/terms/term/@en
					satisfies (contains($citationTextPossibilities, $i)))">
					
					<!-- alt language version detected, create doc:related-content translate English to French -->
					<doc:related-content>
						<doc:related-content-grp content-type="alternate-language-version">
							<doc:related-content-item>
								<doc:related-content-link>
									<ref:lnlink service="TRAVERSE">
										<ref:marker>
											<xsl:text>French Version</xsl:text>
										</ref:marker>
										<ref:locator>
											<ref:locator-key>
												<ref:key-name name="normcite"/>
												<ref:key-value>
													<xsl:attribute name="value">
														<xsl:for-each
															select="$citationContent/citationContent/text() | $citationContent//ci:content/text() | $citationContent//ci:content//ci:span/text()">
															<xsl:call-template name="translate">
																<xsl:with-param name="string" select="normalize-space(.)"/>
																<xsl:with-param name="old"
																	select="$citationTranslationTable/terms/*/@en/string()"/>
																<xsl:with-param name="new"
																	select="$citationTranslationTable/terms/*/@fr/string()"
																/>
															</xsl:call-template>
														</xsl:for-each>
													</xsl:attribute>
												</ref:key-value>
											</ref:locator-key>
											<ref:locator-params>
												<proc:param name="normprotocol" value="CAEditorial"/>
												<proc:param name="countrycode" value="CA"/>
												<proc:param name="targetdoclang">
													<xsl:attribute name="value" select="'fr-CA'"/>
												</proc:param>
											</ref:locator-params>
										</ref:locator>
									</ref:lnlink>
								</doc:related-content-link>
							</doc:related-content-item>
						</doc:related-content-grp>
					</doc:related-content>					
				</xsl:when>
				<xsl:when
					test="
					$sourceLanguage = 'fr' and (some $i in $citationTranslationTable/terms/term/@fr
					satisfies (contains($citationTextPossibilities, $i)))">
					<!-- alt language version detected, create parallelcite translate French to English -->
					<doc:related-content>
						<doc:related-content-grp content-type="alternate-language-version">
							<doc:related-content-item>
								<doc:related-content-link>
									<ref:lnlink service="TRAVERSE">
										<ref:marker>
											<xsl:text>English Version</xsl:text>
										</ref:marker>
										<ref:locator>
											<ref:locator-key>
												<ref:key-name name="normcite"/>
												<ref:key-value>
													<xsl:attribute name="value">
														<xsl:for-each
															select="$citationContent/citationContent/text() | $citationContent//ci:content/text() | $citationContent//ci:content//ci:span/text()">
															<xsl:call-template name="translate">
																<xsl:with-param name="string" select="normalize-space(.)"/>
																<xsl:with-param name="old"
																	select="$citationTranslationTable/terms/*/@fr/string()"/>
																<xsl:with-param name="new"
																	select="$citationTranslationTable/terms/*/@en/string()"
																/>
															</xsl:call-template>
														</xsl:for-each>
													</xsl:attribute>
												</ref:key-value>
											</ref:locator-key>
											<ref:locator-params>
												<proc:param name="normprotocol" value="CAEditorial"/>
												<proc:param name="countrycode" value="CA"/>
												<proc:param name="targetdoclang">
													<xsl:attribute name="value" select="'en-CA'"/>
												</proc:param>
											</ref:locator-params>
										</ref:locator>
									</ref:lnlink>
								</doc:related-content-link>
							</doc:related-content-item>
						</doc:related-content-grp>
					</doc:related-content>
				</xsl:when>
			</xsl:choose>
		</xsl:if>
	</xsl:template>
	
	<xsl:template match="ci:content[ancestor::leg:num or ancestor::leg:officialnum]" priority="25">
		<lnci:content>
			<xsl:apply-templates/>
			<xsl:apply-templates select="parent::ci:cite/following-sibling::text()[1]"/>
		</lnci:content>
	</xsl:template>
	
	
	

	
	
</xsl:stylesheet>
