<?xml version="1.0" encoding="UTF-8"?>
<xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:dita="http://dita.oasis-open.org/architecture/2005/" xmlns:case="http://www.lexis-nexis.com/glp/case" xmlns:casedigest="http://www.lexisnexis.com/xmlschemas/content/legal/case-digest/1/" xmlns:decision="http://www.lexisnexis.com/xmlschemas/content/legal/decision/1/" xmlns="http://www.lexisnexis.com/xmlschemas/content/shared/base/1/" version="2.0" exclude-result-prefixes="dita case">

	<dita:topic xmlns="http://dita.oasis-open.org/architecture/2005/" id="Linxplus-CaseDigest_case.dates">
  <title>case:dates <lnpid>id-NZ07DC-23614</lnpid></title>
  <body>
    <section>
      <p><sourcexml>case:dates</sourcexml>
          becomes<targetxml>casedigest:head/casedigest:caseinfo/decision:dates</targetxml>.</p>
      
      <p><sourcexml>case:decisiondate</sourcexml> becomes
          <targetxml>casedigest:head/casedigest:caseinfo/decision:dates/decision:decisiondate</targetxml>
        populated with below mentioned attributes:
          <sourcexml>case:decisiondate/date/@day</sourcexml> becomes
          <targetxml>decision:decisiondate/@day</targetxml>,
          <sourcexml>case:decisiondate/date/@month</sourcexml> becomes
          <targetxml>decision:decisiondate/@month</targetxml> and
          <sourcexml>case:decisiondate/date/@year</sourcexml> becomes
          <targetxml>decision:decisiondate/@year</targetxml></p>
      
      <p><sourcexml>date</sourcexml> becomes
          <targetxml>casedigest:head/casedigest:caseinfo/decision:dates/decision:decisiondate/date-text</targetxml></p>
 <note>Conversion should not create consecutive <targetxml>casedigest:caseinfo</targetxml>
        elements. When 2 or more consecutive sibling source elements map to<targetxml>casedigest:caseinfo</targetxml>, data should be merged to a single<targetxml>casedigest:caseinfo</targetxml> element unless this would hamper content
        ordering.</note>
     <pre xml:space="preserve">

&lt;case:dates&gt;
    &lt;case:decisiondate&gt;
        &lt;date year="2005" month="03" day="18"&gt;Mar 18, 2005&lt;/date&gt;
    &lt;/case:decisiondate&gt;
&lt;/case:dates&gt;

<b>Becomes</b>

&lt;decision:dates&gt;
    &lt;decision:decisiondate year="2005" month="03" day="18"&gt;
        &lt;date-text&gt;Mar 18, 2005&lt;/date-text&gt;
    &lt;/decision:decisiondate&gt;
&lt;/decision:dates&gt;
</pre>
<note>The formatting of the date-text should not be normalized to YYYY-MM-DD. The attributes are used for  normalization, but the element content should remain the same but whitespace and comma should retain outside the <targetxml>date-text</targetxml> element.</note>
    </section>
    
    <section>
      <title>Changes</title>
      <p>2013-09-24 <ph id="change_20130924_WL_6">XPath updated to reflect the movement of element <targetxml>casedigest:caseinfo</targetxml> along with all its children to <targetxml>casedigest:caseinfo</targetxml> . <targetxml>casedigest:caseinfo</targetxml> and its children
        will be placed within <targetxml>casedigest:head</targetxml> and no longer within  <targetxml>casedigest:body</targetxml>. <b>WebTeam # 235783</b></ph></p>
    </section>
  </body>
	</dita:topic>

	<!--  @@@ This file has been autogenerated.  Remove this comment after manual development complete! @@@  -->
	<!--    Original DITA file location:  DITA\ConversionInstructions\Rosetta\DITA-PAC\NZ07_Linxplus\NZ07DC_Linxplus-CaseDigest\Linxplus-CaseDigest_case.dates.dita  -->
	<!--<xsl:message>Linxplus-CaseDigest_case.dates.xsl requires manual development!</xsl:message>--> 

	<xsl:template match="case:dates">
		<decision:dates>
			<xsl:apply-templates select="@* | node()"/>
		</decision:dates>
	</xsl:template>
	
	<xsl:template match="case:decisiondate">
		<decision:decisiondate>							
			<xsl:call-template name="process_date_attributes"/>		
			<xsl:apply-templates select="@* | node()"/>
		</decision:decisiondate>
	</xsl:template>	

	<xsl:template name="process_date_attributes">
		<!-- this template converts attributes in date/@* to attributes in the target. 
            If no date element exists as a child of the current node, the processing is skipped -->
		<xsl:choose>
			<xsl:when test="date">
				<xsl:variable name="year">
					<xsl:choose>
						<xsl:when test="date/@year='0000'">
							<xsl:value-of select="'2000'"/>
						</xsl:when>
						<xsl:otherwise>
							<xsl:value-of select="date/@year"/>
						</xsl:otherwise>
					</xsl:choose>
				</xsl:variable>
				<xsl:if test="date/@day">
					<xsl:attribute name="day">
						<xsl:value-of select="date/@day"/>
					</xsl:attribute>
				</xsl:if>
				<xsl:if test="date/@year">
					<xsl:attribute name="year">
						<xsl:value-of select="$year"/>
					</xsl:attribute>
				</xsl:if>
				<xsl:if test="date/@month">
					<xsl:attribute name="month">
						<xsl:value-of select="date/@month"/>
					</xsl:attribute>
				</xsl:if>				
				<!--<xsl:if test="date/@month and date/@year and date/@day">					
					<xsl:attribute name="normdate">
						<xsl:value-of select="concat($year, '-', date/@month, '-', date/@day)"/>
					</xsl:attribute>
				</xsl:if>-->
			</xsl:when>
			<xsl:otherwise>
				<!-- don't create attributes if no date element in source -->
			</xsl:otherwise>
		</xsl:choose>
	</xsl:template> 
	
	<xsl:template match="date">
		
		<!--  Original Target XPath:  date-text   -->
		<date-text>
			<xsl:apply-templates select="@* | node()"/>
		</date-text>
		
	</xsl:template>
	
	<xsl:template match="@year"/>
	<xsl:template match="@month"/>
	<xsl:template match="@day"/>

</xsl:stylesheet>